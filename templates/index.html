// ----------------------
// Parche: actualizar el mensaje de la IA desde /analisis
// ----------------------
function actualizarAnalisis() {
    fetch("/analisis")
    .then(r => r.json())
    .then(d => {
        // si el backend devuelve "prediccion" la mostramos, si no queda vacío
        if (d && d.prediccion && d.prediccion !== "clear") {
            mensajeIA.innerText = d.prediccion;
        } else {
            mensajeIA.innerText = "";
        }

        // opcional: si tu /analisis devuelve tambien "valores" y quieres que el gráfico cargue al iniciar,
        // descomenta las dos líneas siguientes:
        // if (Array.isArray(d.valores)) cargarGraficoInicial(d.valores);
    })
    .catch(() => {
        // en caso de error no rompemos la UI
        mensajeIA.innerText = "";
    });
}

// Llamadas: al inicio y periódicamente
actualizarAnalisis();
setInterval(actualizarAnalisis, 5000);

// --- Si quieres que el gráfico se rellene al cargar desde los valores que devuelve /analisis ---
// (descomenta y pega la función cargarGraficoInicial si la necesitas)
/*
function cargarGraficoInicial(valores) {
    // transforma valores numéricos a -1 / +1 como ya haces al agregar
    datos = valores.map(v => {
        const valor = parseFloat(v);
        if (isNaN(valor)) return 0;
        if (valor < 2) return -1;
        return 1;
    });
    grafico.data.labels = datos.map((_, i) => i+1);
    grafico.data.datasets[0].data = datos;
    grafico.data.datasets[0].pointBackgroundColor = datos.map(v => {
        // color según original: azul (-1) / morado (1) / rosa(>=10) -> aquí no tenemos el valor original,
        // pero si /analisis devuelve objetos con valor y color, puedes adaptar esta parte.
        return v < 0 ? 'blue' : 'purple';
    });
    grafico.update();
}
*/
