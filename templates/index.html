<script>
document.addEventListener("DOMContentLoaded",()=>{

  const display = document.getElementById("display");
  const historialDiv = document.getElementById("historial");
  const mensajeIA = document.getElementById("mensaje_ia");
  const horaDiv = document.getElementById("hora");
  const input = document.getElementById("analisisInput");
  const btn = document.getElementById("analizarBtn");
  const graficoCanvas = document.getElementById("grafico").getContext("2d");

  function colorPorCuota(c){ 
    if(c < 2) return "blue"; 
    if(c < 10) return "purple"; 
    return "pink"; 
  }

  // ðŸ”¹ Plugin de lÃ­neas automÃ¡ticas: 2 resistencias y 2 soportes globales
  const referencePlugin = {
    id: 'referenceLines',
    afterDraw: chart => {
      const ctx = chart.ctx;
      const area = chart.chartArea;
      const yScale = chart.scales['y'];
      const data = chart.data.datasets[0].data;
      if(!data || data.length === 0) return;

      // MÃ¡ximos y mÃ­nimos globales
      const ordenados = [...data].sort((a,b)=>b-a);
      const max1 = ordenados[0];
      const max2 = ordenados[1] ?? max1;
      const ordenadosMin = [...data].sort((a,b)=>a-b);
      const min1 = ordenadosMin[0];
      const min2 = ordenadosMin[1] ?? min1;

      const drawLine = (y, color, width=2) => {
        const yPixel = yScale.getPixelForValue(y);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(area.left, yPixel);
        ctx.lineTo(area.right, yPixel);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.restore();
      };

      // LÃ­neas
      drawLine(0, 'white', 2);        // lÃ­nea media
      drawLine(max1, 'red', 2);       // resistencia 1
      drawLine(max2, 'red', 1.5);     // resistencia 2
      drawLine(min1, 'lime', 2);      // soporte 1
      drawLine(min2, 'lime', 1.5);    // soporte 2

      // Etiquetas a la derecha
      ctx.save();
      ctx.font = '11px Arial';
      ctx.fillStyle = 'white';
      ctx.fillText('0', area.right - 20, yScale.getPixelForValue(0) - 4);
      ctx.fillStyle = 'red';
      ctx.fillText(max1.toFixed(2), area.right - 50, yScale.getPixelForValue(max1) - 4);
      ctx.fillText(max2.toFixed(2), area.right - 50, yScale.getPixelForValue(max2) - 4);
      ctx.fillStyle = 'lime';
      ctx.fillText(min1.toFixed(2), area.right - 50, yScale.getPixelForValue(min1) - 4);
      ctx.fillText(min2.toFixed(2), area.right - 50, yScale.getPixelForValue(min2) - 4);
      ctx.restore();
    }
  };

  // ðŸ”¹ GrÃ¡fico principal
  const grafico = new Chart(graficoCanvas, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Tendencia',
        data: [],
        borderColor: 'cyan',
        borderWidth: 2,
        pointRadius: 5,
        pointBackgroundColor: [],
        tension: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'nearest', intersect: false },
      plugins: {
        legend: { display: false },
        zoom: {
          pan: { enabled: true, mode: 'xy', threshold: 5 },
          zoom: {
            wheel: { enabled: true, speed: 0.08 },
            pinch: { enabled: true },
            mode: 'xy'
          }
        }
      },
      scales: {
        x: { ticks: { color: 'cyan' }, grid: { color: '#222' } },
        y: { ticks: { color: 'cyan' }, grid: { color: '#222' } }
      }
    },
    plugins: [Chart.registry.getPlugin('zoom'), referencePlugin]
  });

  // Zoom natural tÃ¡ctil (evita el cuadro gris)
  const hammerArea = new Hammer(document.getElementById('grafico'));
  hammerArea.get('pinch').set({ enable: true });
  hammerArea.on('pinchstart pinchmove pinchend', e => e.preventDefault());

  // ðŸ”¹ Actualizar grÃ¡fico con los datos reales
  function actualizarGrafico(){
    const cuotas = Array.from(historialDiv.children).map(s => parseFloat(s.innerText));
    let valor = 0;
    const serie = cuotas.map(c => {
      if (c < 2) valor -= 1; 
      else valor += 1; 
      return valor;
    });

    grafico.data.labels = serie.map((_,i) => i + 1);
    grafico.data.datasets[0].data = serie;
    grafico.data.datasets[0].pointBackgroundColor = cuotas.map(c => colorPorCuota(c));

    const max = Math.max(...serie, 0);
    const min = Math.min(...serie, 0);
    const absMax = Math.max(Math.abs(max), Math.abs(min)) || 1;
    grafico.options.scales.y.min = -absMax - 1;
    grafico.options.scales.y.max = absMax + 1;

    grafico.update('none');
  }

  // ðŸ”¹ Funciones originales
  function _tecla(t){ if(t === "Borrar") display.innerText = display.innerText.slice(0,-1); else display.innerText += t; }

  function _guardar(){
    const cuota = parseFloat(display.innerText.trim());
    if(isNaN(cuota)) return;
    fetch("/guardar",{ method:"POST", headers:{"Content-Type":"application/x-www-form-urlencoded"}, body:new URLSearchParams({cuota}) })
      .then(r => r.json())
      .then(d => {
        display.innerText = "";
        mensajeIA.innerText = (d.prediccion && d.prediccion !== "clear") ? d.prediccion : "";
        const span = document.createElement("span");
        span.innerText = cuota.toFixed(2);
        span.style.color = "white";
        historialDiv.appendChild(span);
        historialDiv.scrollLeft = historialDiv.scrollWidth;
        actualizarGrafico();
      }).catch(()=> actualizarGrafico());
  }

  function _deshacer(){
    fetch("/borrar_ultimo",{ method:"POST" }).then(()=>{
      if(historialDiv.lastChild) historialDiv.removeChild(historialDiv.lastChild);
      mensajeIA.innerText = "";
      actualizarGrafico();
    }).catch(()=>{
      if(historialDiv.lastChild) historialDiv.removeChild(historialDiv.lastChild);
      actualizarGrafico();
    });
  }

  function _limpiarPantalla(){
    if(!confirm("âš ï¸ Â¿Seguro que deseas borrar el historial y reiniciar la pantalla?")) return;
    fetch("/limpiar_todo",{ method:"POST" }).then(()=>{
      historialDiv.innerHTML = "";
      mensajeIA.innerText = "";
      display.innerText = "";
      grafico.data.labels = [];
      grafico.data.datasets[0].data = [];
      grafico.update();
      alert("âœ… Pantalla e historial reiniciados.");
    }).catch(()=>{
      historialDiv.innerHTML = "";
      grafico.data.labels = [];
      grafico.data.datasets[0].data = [];
      grafico.update();
    });
  }

  // ðŸ”¹ Reloj en vivo
  function actualizarHora(){
    horaDiv.innerText = "ðŸ•’ " + new Date().toLocaleTimeString('es-ES',{hour12:false});
  }
  setInterval(actualizarHora,1000);
  actualizarHora();

  // ðŸ”¹ Analizador de texto
  function analizarEntrada(){
    const texto = input.value.trim();
    const match = texto.match(/([\d.]+)x\s*(\d{2}):(\d{2}):(\d{2})/);
    if(!match) return;
    const mult = parseFloat(match[1]);
    const h = parseInt(match[2]), m = parseInt(match[3]), s = parseInt(match[4]);
    const base = new Date(); base.setHours(h,m,s,0);
    const nuevo = new Date(base.getTime() + mult*60000);
    const nh = String(nuevo.getHours()).padStart(2,"0");
    const nm = String(nuevo.getMinutes()).padStart(2,"0");
    const ns = String(nuevo.getSeconds()).padStart(2,"0");
    input.value = `${match[1]}x ${nh}:${nm}:${ns}`;
  }
  btn.onclick = analizarEntrada;
  input.addEventListener("paste", ()=> setTimeout(analizarEntrada, 100));

  // ðŸ”¹ Eventos y observadores
  window.tecla = _tecla;
  window.guardar = _guardar;
  window.deshacer = _deshacer;
  window.limpiarPantalla = _limpiarPantalla;
  const ro = new MutationObserver(()=> actualizarGrafico());
  ro.observe(historialDiv, { childList:true });
  document.getElementById('grafico').addEventListener('dblclick', ()=> grafico.resetZoom());
  actualizarGrafico();
});
</script>
